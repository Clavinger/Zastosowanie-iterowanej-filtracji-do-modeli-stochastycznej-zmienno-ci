time=1:n),
statenames=bsv_statenames,
paramnames=bsv_paramnames,
covarnames=bsv_covarnames,
times="time",
t0=0,
covar=data.frame(covaryt=c(0,zwroty.sim[s,1:n]),
time=0:n),
tcovar="time",
rmeasure=Csnippet(bsv_rmeasure),
dmeasure=Csnippet(bsv_dmeasure),
rprocess=discrete.time.sim(step.fun=Csnippet(bsv_rproc.filt),delta.t=1),
initializer=Csnippet(bsv_initializer),
toEstimationScale=Csnippet(bsv_toEstimationScale),
fromEstimationScale=Csnippet(bsv_fromEstimationScale)
)
s=1
start_time <- Sys.time()
t.if.bsv <- system.time({
if.bsv <- foreach(i=1:bsvlist[[5]][run_level] ,
.packages='pomp', .combine=c,.export = "bsvlist",
.options.multicore=list(set.seed=TRUE)) %dopar% try(
pomp::mif2(bsv.filt,start=params_test,Np=bsvlist[[1]][run_level] , Nmif=bsvlist[[2]][run_level] ,cooling.type="geometric",
cooling.fraction.50=bsv_cooling.fraction.50,
transform=TRUE,
rw.sd = rw.sd(
mu_h      = bsv_rw.sd_rp,
phi       = bsv_rw.sd_rp,
sigma_eta = bsv_rw.sd_rp
)
)
)
L.if.bsv <- foreach(i=1:bsvlist[[5]][run_level] ,.packages='pomp', .export = "bsvlist",
.combine=rbind,.options.multicore=list(set.seed=TRUE)) %dopar% try(
logmeanexp(
replicate(bsvlist[[3]][run_level] ,
logLik(pfilter(bsv.filt,params=coef(if.bsv[[i]]),Np=bsvlist[[1]][run_level]  ))
),
se=TRUE)
)
H.if.bsv<- foreach(i=1:bsvlist[[5]][run_level] ,.packages='pomp', .export = "bsvlist",
.combine=cbind,.options.multicore=list(set.seed=TRUE)) %dopar% try(
exp(pfilter(bsv.filt,params=coef(if.bsv[[i]]),Np=bsvlist[[1]][run_level],pred.mean=TRUE)@pred.mean[1,])
)
})
stopCluster(cl)
end_time <- Sys.time()
czas.obliczen[s,1]=end_time - start_time
###trzy szybkosci filtru: 1 -szybki, 2 -sredni, 3 - wolny
run_level <- 1
#liczba czasteczek
bsv_Np <-          c(100,1e3,1e3)
bsv_Nmif <-        c(10, 50,150)
bsv_Nreps_eval <-  c(4,  10,  20)
bsv_Nreps_local <- c(4, 10, 10)
bsv_Nreps_global <-c(4, 10, 10)
bsvlist<-list(bsv_Np ,bsv_Nmif,bsv_Nreps_eval,
bsv_Nreps_local,bsv_Nreps_global )
#parametry do metody mif2
bsv_rw.sd_rp <- 0.02
bsv_rw.sd_ivp <- 0.1
bsv_cooling.fraction.50 <- 0.5
detectCores()
cl <- makeCluster(3, type = "SOCK")
registerDoSNOW(cl)
start_time <- Sys.time()
t.if.bsv <- system.time({
if.bsv <- foreach(i=1:bsvlist[[5]][run_level] ,
.packages='pomp', .combine=c,.export = "bsvlist",
.options.multicore=list(set.seed=TRUE)) %dopar% try(
pomp::mif2(bsv.filt,start=params_test,Np=bsvlist[[1]][run_level] , Nmif=bsvlist[[2]][run_level] ,cooling.type="geometric",
cooling.fraction.50=bsv_cooling.fraction.50,
transform=TRUE,
rw.sd = rw.sd(
mu_h      = bsv_rw.sd_rp,
phi       = bsv_rw.sd_rp,
sigma_eta = bsv_rw.sd_rp
)
)
)
L.if.bsv <- foreach(i=1:bsvlist[[5]][run_level] ,.packages='pomp', .export = "bsvlist",
.combine=rbind,.options.multicore=list(set.seed=TRUE)) %dopar% try(
logmeanexp(
replicate(bsvlist[[3]][run_level] ,
logLik(pfilter(bsv.filt,params=coef(if.bsv[[i]]),Np=bsvlist[[1]][run_level]  ))
),
se=TRUE)
)
H.if.bsv<- foreach(i=1:bsvlist[[5]][run_level] ,.packages='pomp', .export = "bsvlist",
.combine=cbind,.options.multicore=list(set.seed=TRUE)) %dopar% try(
exp(pfilter(bsv.filt,params=coef(if.bsv[[i]]),Np=bsvlist[[1]][run_level],pred.mean=TRUE)@pred.mean[1,])
)
})
stopCluster(cl)
end_time <- Sys.time()
czas.obliczen[s,1]=end_time - start_time
end_time - start_time
czas.obliczen[s,1]
r.if.bsv <- data.frame(logLik=L.if.bsv[,1],logLik_se=L.if.bsv[,2],t(sapply(if.bsv,coef)))
r.if.bsv <- data.frame(logLik=L.if.bsv[,1],logLik_se=L.if.bsv[,2],t(sapply(if.bsv,coef)))
L.if.bsv[,1]
bsv.filt<-pomp(data=data.frame(y=zwroty.sim[s,1:n],
time=1:n),
statenames=bsv_statenames,
paramnames=bsv_paramnames,
covarnames=bsv_covarnames,
times="time",
t0=0,
covar=data.frame(covaryt=c(0,zwroty.sim[s,1:n]),
time=0:n),
tcovar="time",
rmeasure=Csnippet(bsv_rmeasure),
dmeasure=Csnippet(bsv_dmeasure),
rprocess=discrete.time.sim(step.fun=Csnippet(bsv_rproc.filt),delta.t=1),
initializer=Csnippet(bsv_initializer),
toEstimationScale=Csnippet(bsv_toEstimationScale),
fromEstimationScale=Csnippet(bsv_fromEstimationScale)
)
detectCores()
cl <- makeCluster(3, type = "SOCK")
registerDoSNOW(cl)
start_time <- Sys.time()
t.if.bsv <- system.time({
if.bsv <- foreach(i=1:bsvlist[[5]][run_level] ,
.packages='pomp', .combine=c,.export = "bsvlist",
.options.multicore=list(set.seed=TRUE)) %dopar% try(
pomp::mif2(bsv.filt,start=params_test,Np=bsvlist[[1]][run_level] , Nmif=bsvlist[[2]][run_level] ,cooling.type="geometric",
cooling.fraction.50=bsv_cooling.fraction.50,
transform=TRUE,
rw.sd = rw.sd(
mu_h      = bsv_rw.sd_rp,
phi       = bsv_rw.sd_rp,
sigma_eta = bsv_rw.sd_rp
)
)
)
L.if.bsv <- foreach(i=1:bsvlist[[5]][run_level] ,.packages='pomp', .export = "bsvlist",
.combine=rbind,.options.multicore=list(set.seed=TRUE)) %dopar% try(
logmeanexp(
replicate(bsvlist[[3]][run_level] ,
logLik(pfilter(bsv.filt,params=coef(if.bsv[[i]]),Np=bsvlist[[1]][run_level]  ))
),
se=TRUE)
)
H.if.bsv<- foreach(i=1:bsvlist[[5]][run_level] ,.packages='pomp', .export = "bsvlist",
.combine=cbind,.options.multicore=list(set.seed=TRUE)) %dopar% try(
exp(pfilter(bsv.filt,params=coef(if.bsv[[i]]),Np=bsvlist[[1]][run_level],pred.mean=TRUE)@pred.mean[1,])
)
})
stopCluster(cl)
end_time <- Sys.time()
czas.obliczen[s,1]=end_time - start_time
r.if.bsv <- data.frame(logLik=L.if.bsv[,1],logLik_se=L.if.bsv[,2],t(sapply(if.bsv,coef)))
parametry.est=r.if.bsv[which.max(r.if.bsv$logLik),]
L.if.bsv[,1]
params_test=c(
mu=mu,
phi=phi,
sigma_eta=sigma
)
params_test
bsv.filt<-pomp(data=data.frame(y=zwroty.sim[s,1:n],
time=1:n),
statenames=bsv_statenames,
paramnames=bsv_paramnames,
covarnames=bsv_covarnames,
times="time",
t0=0,
covar=data.frame(covaryt=c(0,zwroty.sim[s,1:n]),
time=0:n),
tcovar="time",
rmeasure=Csnippet(bsv_rmeasure),
dmeasure=Csnippet(bsv_dmeasure),
rprocess=discrete.time.sim(step.fun=Csnippet(bsv_rproc.filt),delta.t=1),
initializer=Csnippet(bsv_initializer),
toEstimationScale=Csnippet(bsv_toEstimationScale),
fromEstimationScale=Csnippet(bsv_fromEstimationScale)
)
detectCores()
cl <- makeCluster(3, type = "SOCK")
registerDoSNOW(cl)
start_time <- Sys.time()
t.if.bsv <- system.time({
if.bsv <- foreach(i=1:bsvlist[[5]][run_level] ,
.packages='pomp', .combine=c,.export = "bsvlist",
.options.multicore=list(set.seed=TRUE)) %dopar% try(
pomp::mif2(bsv.filt,start=params_test,Np=bsvlist[[1]][run_level] , Nmif=bsvlist[[2]][run_level] ,cooling.type="geometric",
cooling.fraction.50=bsv_cooling.fraction.50,
transform=TRUE,
rw.sd = rw.sd(
mu      = bsv_rw.sd_rp,
phi       = bsv_rw.sd_rp,
sigma_eta = bsv_rw.sd_rp
)
)
)
L.if.bsv <- foreach(i=1:bsvlist[[5]][run_level] ,.packages='pomp', .export = "bsvlist",
.combine=rbind,.options.multicore=list(set.seed=TRUE)) %dopar% try(
logmeanexp(
replicate(bsvlist[[3]][run_level] ,
logLik(pfilter(bsv.filt,params=coef(if.bsv[[i]]),Np=bsvlist[[1]][run_level]  ))
),
se=TRUE)
)
H.if.bsv<- foreach(i=1:bsvlist[[5]][run_level] ,.packages='pomp', .export = "bsvlist",
.combine=cbind,.options.multicore=list(set.seed=TRUE)) %dopar% try(
exp(pfilter(bsv.filt,params=coef(if.bsv[[i]]),Np=bsvlist[[1]][run_level],pred.mean=TRUE)@pred.mean[1,])
)
})
stopCluster(cl)
end_time <- Sys.time()
czas.obliczen[s,1]=end_time - start_time
r.if.bsv <- data.frame(logLik=L.if.bsv[,1],logLik_se=L.if.bsv[,2],t(sapply(if.bsv,coef)))
parametry.est=r.if.bsv[which.max(r.if.bsv$logLik),]
r.if.bsv[which.max(r.if.bsv$logLik),]
parametry.est=r.if.bsv[which.max(r.if.bsv$logLik),3:5]
parametry.est=array(data=NA, dim=c(3,sym+1,4),dimnames=list(parametry=c("mu","phi","sigma"),
numer_symulacji=c(1:sym,'srednia'),
metoda=c("QML","LW","IF","PCMC")))
parametry.est[s,3]=r.if.bsv[which.max(r.if.bsv$logLik),3:5]
parametry.est[,s,3]=r.if.bsv[which.max(r.if.bsv$logLik),3:5]
parametry.est[,s,3]
parametry.est[1:3,s,3]=r.if.bsv[which.max(r.if.bsv$logLik),3:5]
parametry.est[1:3,s,3]
parametry.est=array(data=NA, dim=c(3,sym+1,4),dimnames=list(parametry=c("mu","phi","sigma"),
numer_symulacji=c(1:sym,'srednia'),
metoda=c("QML","LW","IF","PCMC")))
parametry.est[1:3,s,3]
r.if.bsv[which.max(r.if.bsv$logLik),3:5]
as.vector(r.if.bsv[which.max(r.if.bsv$logLik),3:5])
parametry.est[1:3,s,3]=as.vector(r.if.bsv[which.max(r.if.bsv$logLik),3:5])
parametry.est[1:3,s,3]
as.vector(r.if.bsv[which.max(r.if.bsv$logLik),3:5])
?as.vector
as.vector(r.if.bsv[which.max(r.if.bsv$logLik),3:5],mode="numeric")
parametry.est=array(data=NA, dim=c(3,sym+1,4),dimnames=list(parametry=c("mu","phi","sigma"),
numer_symulacji=c(1:sym,'srednia'),
metoda=c("QML","LW","IF","PCMC")))
parametry.est[1:3,s,3]=as.vector(r.if.bsv[which.max(r.if.bsv$logLik),3:5],mode="numeric")
parametry.est[1:3,s,3]
pfilter(bsv.filt,params=params_nowe2,
Np=bsvlist[[1]][run_level],filter.traj=T)
pfilter(bsv.filt,params=parametry.est[1:3,s,3],
Np=bsvlist[[1]][run_level],filter.traj=T)
parametry.est=array(data=NA, dim=c(3,sym+1,4),dimnames=list(parametry=c("mu","phi","sigma_eta"),
numer_symulacji=c(1:sym,'srednia'),
metoda=c("QML","LW","IF","PCMC")))
parametry.blad=array(data=NA,dim=c(3,sym+1,4,5),dimnames=list(parametry=c("mu","phi","sigma_eta"),
numer_symulacji=c(1:sym,'srednia'),
metoda=c("QML","LW","IF","PCMC"),
blad=c("ME","RMSE","MAE",
"MPE","MAPE")))
log.volatility.est=array(data=NA,dim=c(sym+1,4),dimnames=list(numer_symulacji=c(1:sym,'srednia'),
metoda=c("QML","LW","IF","PCMC")))
log.volatility.blad=array(data=NA,dim=c(sym+1,4,5),dimnames=list(numer_symulacji=c(1:sym,'srednia'),
metoda=c("QML","LW","IF","PCMC"),
blad=c("ME","RMSE","MAE",
"MPE","MAPE")))
czas.obliczen=array(data=NA,dim=c(sym+1,4))
zwroty.sim=array(data=NA,dim=c(sym+1,n))
log.volatility.sim=array(data=NA,dim=c(sym+1,n))
parametry.est[1:3,s,3]=as.vector(r.if.bsv[which.max(r.if.bsv$logLik),3:5],mode="numeric")
parametry.est[1:3,s,3]
pfilter(bsv.filt,params=parametry.est[1:3,s,3],
Np=bsvlist[[1]][run_level],filter.traj=T)
pfilter(bsv.filt,params=parametry.est[1:3,s,3],
Np=bsvlist[[1]][run_level],filter.traj=T)@filter.traj[1,1,2:(dim(pf1@filter.traj)[3])]
pfilter(bsv.filt,params=parametry.est[1:3,s,3],
Np=bsvlist[[1]][run_level],filter.traj=T)@filter.traj[1,1,2:n]
pfilter(bsv.filt,params=parametry.est[1:3,s,3],
Np=bsvlist[[1]][run_level],filter.traj=T)@filter.traj[1,1,1:n]
pfilter(bsv.filt,params=parametry.est[1:3,s,3],
Np=bsvlist[[1]][run_level],filter.traj=T)@filter.traj[1,1,]
zwroty.sim[s,1:n]
log.volatility.list  <-pomp::simulate(bsv.model,nsim=sym,seed=123,params=c(mu=mu,phi=phi,sigma_eta=sigma),
states = TRUE, obs = TRUE)
str(log.volatility.list$ states)
zwroty.sim= log.volatility.list$obs[1,,]
log.volatility.sim=log.volatility.list$states[1,,]
log.volatility.list$obs[1,,]
str(log.volatility.list$obs[1,,] )
str(log.volatility.list$states[1,,] )
str(log.volatility.list$states )
pfilter(bsv.filt,params=parametry.est[1:3,s,3],
Np=bsvlist[[1]][run_level],filter.traj=T)@filter.traj[1,1,2:(n+1)]
parametry.est=array(data=NA, dim=c(4,3,sym+1),dimnames=list(metoda=c("QML","LW","IF","PCMC"),
parametry=c("mu","phi","sigma_eta"),
numer_symulacji=c(1:sym,'srednia')))
parametry.est[3,1:3,s]=as.vector(r.if.bsv[which.max(r.if.bsv$logLik),3:5],mode="numeric")
parametry.est[3,1:3,s]
pfilter(bsv.filt,params=parametry.est[3,1:3,s],
Np=bsvlist[[1]][run_level],filter.traj=T)@filter.traj[1,1,2:(n+1)]
parametry.blad=array(data=NA,dim=c(4,3,sym+1,5),dimnames=list(metoda=c("QML","LW","IF","PCMC"),
parametry=c("mu","phi","sigma_eta"),
numer_symulacji=c(1:sym,'srednia'),
blad=c("ME","RMSE","MAE",
"MPE","MAPE")))
#metoda x  nr symulaci x nr obserwacji
log.volatility.est=array(data=NA,dim=c(4,sym+1,n),dimnames=list( metoda=c("QML","LW","IF","PCMC"),
numer_symulacji=c(1:sym,'srednia'),
numer_obserwacji=1:n))
log.volatility.blad=array(data=NA,dim=c(sym+1,4,5),dimnames=list(metoda=c("QML","LW","IF","PCMC"),
numer_symulacji=c(1:sym,'srednia'),
blad=c("ME","RMSE","MAE",
"MPE","MAPE")))
log.volatility.blad=array(data=NA,dim=c(4,sym+1,5),dimnames=list(metoda=c("QML","LW","IF","PCMC"),
numer_symulacji=c(1:sym,'srednia'),
blad=c("ME","RMSE","MAE",
"MPE","MAPE")))
?Sys.time()
as.vector(pfilter(bsv.filt,params=parametry.est[3,1:3,s],
Np=bsvlist[[1]][run_level],filter.traj=T)@filter.traj[1,1,2:(n+1)],mode="numeric")
log.volatility.est[3,s,]=as.vector(pfilter(bsv.filt,params=parametry.est[3,1:3,s],
Np=bsvlist[[1]][run_level],filter.traj=T)@filter.traj[1,1,2:(n+1)],mode="numeric")
log.volatility.est[3,s,]
parametry.est[3, ,s]=as.vector(r.if.bsv[which.max(r.if.bsv$logLik),3:5],mode="numeric")
parametry.est[3, ,s]
parametry.blad[3,,]
parametry.blad[3,,s,]
?sapply(list, function)
?sapply
parametry.est[3, ,s]
apply(parametry.est[3, ,s], margin=2)
apply(parametry.est[3, ,s], margin=2,FUN = accuracy)
apply(parametry.est[3, ,s], margin=1,FUN = accuracy)
parametry.est[3, ,s]
dim(parametry.est[3, ,s])
dim(as.matrix(parametry.est[3, ,s]))
apply(as.matrix(parametry.est[3, ,s]), margin=2,FUN = accuracy)
apply(as.matrix(parametry.est[3, ,s]), MARGIN=2,FUN = accuracy)
apply(as.matrix(parametry.est[3, ,s]), MARGIN=2,FUN = accuracy,x=c(mu,phi,sigma))
apply(as.matrix(parametry.est[3, ,s]), MARGIN=1,FUN = accuracy,x=c(mu,phi,sigma))
x=c(mu,phi,sigma)
c(mu,phi,sigma)
accuracy(f= parametry.est[3, ,s],x=c(mu,phi,sigma))
i=1
params_test[i]
for(i in 1:3) parametry.blad[3,i,s,]=as.vector(accuracy(f= parametry.est[3,i ,s],x=params_test[i]),mode="numeric")
parametry.blad[3,,s,]
parametry.est[3, ,s]
params_test
log.volatility.blad[3,s,]
zwroty.sim[s,]= log.volatility.list$obs[1,,]
log.volatility.sim[s,]=log.volatility.list$states[1,,]
#metoda x  nr symulaci x nr obserwacji
log.volatility.est=array(data=NA,dim=c(4,sym+1,n),dimnames=list( metoda=c("QML","LW","IF","PCMC"),
numer_symulacji=c(1:sym,'srednia'),
numer_obserwacji=1:n))
#metoda x  nr symulaci x rodzaj bledu
log.volatility.blad=array(data=NA,dim=c(4,sym+1,5),dimnames=list(metoda=c("QML","LW","IF","PCMC"),
numer_symulacji=c(1:sym,'srednia'),
blad=c("ME","RMSE","MAE",
"MPE","MAPE")))
#metoda x  nr symulaci
zwroty.sim[s,]= log.volatility.list$obs[1,,]
log.volatility.sim[s,]=log.volatility.list$states[1,,]
log.volatility.list$obs[1,,]
zwroty.sim[s,]= as.vector(log.volatility.list$obs[1,,],mode = "numeric")
as.vector(log.volatility.list$obs[1,,],mode = "numeric")
log.volatility.list$obs[1,,]
log.volatility.list$obs[1,1,]
plot(log.volatility.list$obs[1,1,],type='l')
zwroty.sim[s,]= log.volatility.list$obs[1,1,]
zwroty.sim[s,]
log.volatility.list$states[1,1,]
plot(log.volatility.list$states[1,1,] ,type='l')
zwroty.sim[s,]= log.volatility.list$obs[1,1,]
log.volatility.sim[s,]= log.volatility.list$states[1,1,]
as.vector(accuracy(f=log.volatility.est[3,s,],x=log.volatility.sim[s,])
,mode="numeric")
log.volatility.est[3,s,]=as.vector(pfilter(bsv.filt,params=parametry.est[3,1:3,s],
Np=bsvlist[[1]][run_level],filter.traj=T)@filter.traj[1,1,2:(n+1)],mode="numeric")
log.volatility.blad[3,s,]=as.vector(accuracy(f=log.volatility.est[3,s,],x=log.volatility.sim[s,]),mode="numeric")
log.volatility.blad[3,s,]
lines(log.volatility.est[3,s,],col='red')
optim(c(mu,phi,sigma),KF.log,
method="L-BFGS-B",hessian = T,lower=c(-Inf,-1,0),upper=c(Inf,1,Inf))
log.volatility.list$obs[1,2,]
zwroty.sim[s,]
y=zwroty.sim[s,]
KF.opt<-optim(c(mu,phi,sigma),KF.log,
method="L-BFGS-B",hessian = T,lower=c(-Inf,-1,0),upper=c(Inf,1,Inf))
library(fkf)
library(FKF)
OUss <- function(mu,phi,sigma){
Tt <- matrix(phi,ncol=1)
Zt <- matrix(1,ncol=1)
ct <- matrix(-1.27,ncol=1)
dt <- matrix(mu*(1-phi), nrow = 1)
GGt<- matrix(pi^2/2,nrow = 1,ncol=1)
HHt<- matrix(sigma^2,nrow=1,ncol=1)
a0 <-  as.vector(matrix(mu+1.27))
P0 <- matrix(1,nrow=1,ncol=1)
return(list(a0 = a0, P0 = P0, ct = ct, dt = dt, Zt = Zt, Tt = Tt, GGt = GGt,
HHt = HHt))
}
KF.log <- function(theta) {
sp <- OUss(theta[1], theta[2], theta[3])
ans <- fkf(a0 = sp$a0, P0 = sp$P0, dt = sp$dt, ct = sp$ct, Tt = sp$Tt,
Zt = sp$Zt, HHt = sp$HHt, GGt = sp$GGt, yt =matrix(y, nrow=1,ncol=n))
return(-ans$logLik)
}
KF <- function(theta) {
sp <- OUss(theta[1], theta[2], theta[3])
ans <- fkf(a0 = sp$a0, P0 = sp$P0, dt = sp$dt, ct = sp$ct, Tt = sp$Tt,
Zt = sp$Zt, HHt = sp$HHt, GGt = sp$GGt, yt =matrix(y, nrow=1,ncol=n))
return(ans$att[1,])
}
KF.opt<-optim(c(mu,phi,sigma),KF.log,
method="L-BFGS-B",hessian = T,lower=c(-Inf,-1,0),upper=c(Inf,1,Inf))
KF.opt
parametry.est[1, ,s]=KF.opt$par
as.vector(accuracy(f= parametry.est[1,i ,s],x=params_test[i]),mode="numeric")
for(i in 1:3) parametry.blad[1,i,s,]=as.vector(accuracy(f= parametry.est[1,i ,s],x=params_test[i]),mode="numeric")
parametry.blad[1,,s,]
KF.opt$par
optim(c(mu,phi,sigma),KF.log,
method="L-BFGS-B",hessian = T,lower=c(-Inf,-1,0),upper=c(Inf,1,Inf))
mu
y
plot(y,type='l')
?optim
optim
optim(c(mu,phi,sigma),KF.log,
method="Nelder-Mead")
y=log(zwroty.sim[s,]^2)
KF.opt<-optim(c(mu,phi,sigma),KF.log,
method="L-BFGS-B",hessian = T,lower=c(-Inf,-1,0),upper=c(Inf,1,Inf))
parametry.est[1, ,s]=KF.opt$par
for(i in 1:3) parametry.blad[1,i,s,]=as.vector(accuracy(f= parametry.est[1,i ,s],x=params_test[i]),mode="numeric")
KF.opt$par
parametry.blad[1, ,s,]
plot(log.volatility.sim[s,],type='l')
lines((KF(KF.opt$par )+1.27),col='red')
lines((KF(KF.opt$par )),col='red')
log.volatility.est[1,s,]=(KF(KF.opt$par))
as.vector(accuracy(f=log.volatility.est[1,s,],x=log.volatility.sim[s,]),mode="numeric")
log.volatility.blad[1,s,]=as.vector(accuracy(f=log.volatility.est[1,s,],x=log.volatility.sim[s,]),mode="numeric")
log.volatility.blad[1,s,]
r.if.bsv[which.max(r.if.bsv$logLik),]
as.numeric(r.if.bsv[which.max(r.if.bsv$logLik),1])
parametry.est[1,1:3,s]
logLik(pfilter(bsv.filt,params=parametry.est[1,1:3,s],
Np=bsvlist[[1]][run_level]))
KF.opt
stochVCode <- nimbleCode({
x[1] ~ dnorm(mu*(1-phi) + phi * x0, var = sigmaSquaredInv)
y[1] ~ dnorm(0, var =  exp(x[1]))
for(t in 2:T){
x[t] ~ dnorm(mu*(1-phi) + phi * x[t-1],  var = sigmaSquaredInv)
y[t] ~ dnorm(0, var = exp(x[t]))
}
x0 ~ dnorm(0, var = sigmaSquaredInv)
phi <- dunif(-1,1)
sigmaSquaredInv ~ dgamma(5, 20)
mu ~ dnorm(-0.5, var = 100)
})
stochVolModel <- nimbleModel(code = stochVCode, name ='stochVol',
constants = list(T = n),  data = list(y = as.vector(zwroty.sim[s,])),
inits = list(mu = mu,  phi = phi,
sigmaSquaredInv = sigma^2))
stochVCode <- nimbleCode({
x[1] ~ dnorm(mu*(1-phi) + phi * x0, var = sigmaSquaredInv)
y[1] ~ dnorm(0, var =  exp(x[1]))
for(t in 2:T){
x[t] ~ dnorm(mu*(1-phi) + phi * x[t-1],  var = sigmaSquaredInv)
y[t] ~ dnorm(0, var = exp(x[t]))
}
x0 ~ dnorm(0, var = sigmaSquaredInv)
phi ~ dunif(-1,1)
sigmaSquaredInv ~ dgamma(5, 20)
mu ~ dnorm(-0.5, var = 100)
})
stochVolModel <- nimbleModel(code = stochVCode, name ='stochVol',
constants = list(T = n),  data = list(y = as.vector(zwroty.sim[s,])),
inits = list(mu = mu,  phi = phi,
sigmaSquaredInv = sigma^2))
plot(density(sigmaSquaredSamples))
CstochVolModel <- compileNimble(stochVolModel)
stochVolLiuWestFilter <- buildLiuWestFilter(model = stochVolModel, nodes ='x',
params = c("mu","phi","sigmaSquaredInv"))
CstochVolLiuWestFilter <- compileNimble(stochVolLiuWestFilter,
project = stochVolModel)
CstochVolLiuWestFilter$run(1000)
muSamples <- as.matrix(CstochVolLiuWestFilter$mvEWSamples,'mu')
plot(density(muSamples))
phiSamples <- as.matrix(CstochVolLiuWestFilter$mvEWSamples,'phi')
plot(density(phiSamples))
mu
phi
sigmaSamples <- as.matrix(CstochVolLiuWestFilter$mvEWSamples,'sigmaSquaredInv')
plot(density(sigmaSamples))
sigma^2
c(mean(muSamples),mean(phiSamples),mean(sigmaSamples))
parametry.est[2, ,s]=c(mean(muSamples),mean(phiSamples),mean(sigmaSamples))
for(i in 1:3) parametry.blad[2,i,s,]=as.vector(accuracy(f= parametry.est[2,i ,s],x=params_test[i]),mode="numeric")
log.volatility.est[2,s,]=as.vector(pfilter(bsv.filt,params=parametry.est[2,1:3,s],
Np=bsvlist[[1]][run_level],filter.traj=T)@filter.traj[1,1,2:(n+1)],mode="numeric")
log.volatility.blad[2,s,]=as.vector(accuracy(f=log.volatility.est[2,s,],x=log.volatility.sim[s,]),mode="numeric")
log.lik[2,s]=logLik(pfilter(bsv.filt,params=parametry.est[2,1:3,s],
Np=bsvlist[[1]][run_level]))
log.lik[2,s]
#metoda x  nr symulaci
log.lik=array(data=NA,dim=c(4,sym+1))
log.lik[2,s]=logLik(pfilter(bsv.filt,params=parametry.est[2,1:3,s],
Np=bsvlist[[1]][run_level]))
log.lik[2,s]
log.volatility.blad[2,s,]
log.volatility.est[2,s,]
parametry.blad[2,i,s,]
parametry.blad[2,,s,]
parametry.est[2, ,s]
